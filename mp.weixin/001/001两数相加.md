## 两数相加
审题是一件很重要的事情，首先[看下题目](https://leetcode-cn.com/problems/add-two-numbers/)

![两数相加](https://s1.ax1x.com/2020/08/18/dMJJCn.png)
首先是有两个非空的链表，里面每个节点分别存了对应数字的每一位，并且是倒序存的，意思就是我们在遍历链表的时候正序遍历就可以了，不需要借助**栈**来辅助操作，这一题其实可以参考[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)，他们的解法是类似的。

所以我觉得这一题可以归结为`easy`的行列，但是官方把它归结为`medium`应该是考虑到是21题的进阶，需要把数学的加法应用到代码里面，并且需要小心进位`carry`。

话不多说，代码来袭

## talk is cheap, show me the code
```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode newHead = new ListNode(0);// 申请一个新的链表存储计算的结果
    int carry = 0;// 1️⃣表示进位，当退出循环的时候也要考虑进位，很多面试者容易忽略这一点
    ListNode p1 = l1;
    ListNode p2 = l2;
    ListNode curr = newHead;// 2️⃣不能对newHead直接操作，因为我们最后是要返回这个newHead的，所以要有一个新的指针指向它
    while(p1 != null || p2 != null) {
        int val1 = p1 != null ? p1.val : 0;
        int val2 = p2 != null ? p2.val : 0;
        // 3️⃣ 这里其实就是小学数学加法的只是，考虑进位就行了，没啥好说的
        int sum = ((val1 + val2)  + (carry > 0 ? carry : 0)) % 10;
        carry = ((val1 + val2)  + (carry > 0 ? carry : 0)) / 10;
        curr.next = new ListNode(sum);
        curr = curr.next;// 4️⃣考察链表的基本操作
        if(p1 != null)
            p1 = p1.next;
        if(p2 != null)
            p2 = p2.next;
    }
    // 5️⃣循环结束后也要考虑进位
    if (carry > 0) {
        curr.next = new ListNode(carry);
    }
    // 6️⃣这里就能体会到2️⃣的作用了
    return newHead.next;
}
```
上面需要注意的点，在注释里面已经标出来。

PS：to 前端小伙伴，因为我对js也不熟，就没法写js的代码了，但是思路是一样的。

## 写在最后
我觉得这一题也就这一种解法，这也是最容易想出来的解法，最终的时间复杂度也是只有O(n),所以没啥可以优化的了

今天时间比较仓促，也没有时间做视频了，其实视频也就是做几页ppt，把这个过程慢动作放出来，读者朋友们也可以自己尝试做一个视频，加深对题目的理解。

另外，还想说的是，晚上可以早点休息，早上早点起来（不知道现在的95以及00后是不是认同呢），我现在正在坚持这种做法。晚上11点半睡觉，早上7点起床，一周4-5次，去公司健身或者去游泳，我会继续坚持下去的，一起加油！！！奥利给。


